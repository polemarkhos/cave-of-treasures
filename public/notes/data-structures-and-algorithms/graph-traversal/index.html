<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    Graph Traversal | The Cave of Treasures
    
</title>

<link rel="canonical" href="http://localhost:1313/notes/data-structures-and-algorithms/graph-traversal/"/>

<meta property="og:url" content="http://localhost:1313/notes/data-structures-and-algorithms/graph-traversal/">
  <meta property="og:site_name" content="The Cave of Treasures">
  <meta property="og:title" content="Graph Traversal">
  <meta property="og:description" content="Everything you wanted to know about going down and along trees">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2025-08-09T13:19:20+01:00">
    <meta property="article:modified_time" content="2025-08-09T13:19:20+01:00">












<link rel="stylesheet" href="/assets/combined.min.62d3d68b86ab80ae1348b39991816cb99fd247ba4c3436eaa0d0d7e260019425.css" media="all">











    




</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">The Cave of Treasures</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/notes" >
                /notes
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/translations" >
                /translations
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/notes/">Notes</a><span class="breadcrumbs-separator">/</span><a href="/notes/data-structures-and-algorithms/">Data Structures and Algorithms</a><span class="breadcrumbs-separator">/</span>
        <a href="/notes/data-structures-and-algorithms/graph-traversal/">Graph Traversal</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">Graph Traversal</h1>
        <p class="single-summary">Everything you wanted to know about going down and along trees</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-08-09T13:19:20&#43;01:00">August 9, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
      <aside class="toc">
        <p><strong>Table of contents</strong></p>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#graph-traversal">Graph Traversal</a></li>
        <li><a href="#shortest-paths">Shortest paths</a></li>
      </ul>
    </li>
  </ul>
</nav>
      </aside>
    
    <div class="single-content">
      <h3 class="heading" id="graph-traversal">
  Graph Traversal
  <a class="anchor" href="#graph-traversal">#</a>
</h3>
<h4 class="heading" id="representing-graphs">
  Representing Graphs
  <a class="anchor" href="#representing-graphs">#</a>
</h4>
<p>We can represent graphs in multiple ways.</p>
<ul>
<li>
<p>Adjacency List. Each node has a list of nodes to which there is an edge from
that node, stored as an array of vectors (in Cpp), or just a normal list of
lists in python. Each element is a list representing the
edges attached to that node.</p>
<p>e.g. <code>[[2], [3,4], [4], [1]]</code> !! Assuming we index from 1 and not 0</p>
<p>or <code>vector&lt;int&gt; adj[n]</code> where n is the number of nodes.</p>
<p>Then <code>adj[1].push_back(2)</code> adds edge 2 to node 1, etc.
In python we would do <code>adj[1].append(2)</code></p>
<p>Weighted graphs can be represented with <code>vector&lt;pair&lt;int, int&gt;&gt; adj[N]</code> or maybe
by using a list of dicts in python?</p>
</li>
<li>
<p>Adjacency matrix. Using matrices and graph theory here. We can represent the
graph as a matrix by adding a 1 to an n*n matrix, whre n is the number of
nodes, at each point where two nodes share an edge. For example, if nodes 1
and 2 share an edge, we add a 1 at 1,2. Representing weights is easier due to
the fact that we can just add the weight at the relevant location, e.g. 5
instead of 1.</p>
<p>However, there are a lot of zeroes, especially for larger graphs. We don&rsquo;t
generally like sparse matrices.</p>
</li>
<li>
<p>Edge list. In a vector of pairs or another python list of lists, we simply
represent the edge relationships as pairs of nodes that share an edge. e.g. if
1, 2 share an edge, we have <code>edges.push_back({1,2})</code> in Cpp, or
<code>edges.append([1,2])</code> in python.</p>
<p>We can also add a value for the weight of the edge.</p>
<p>Time complexity is O(m+n) because it processes n nodes and m edges once.</p>
</li>
</ul>
<h4 class="heading" id="depth-first-search">
  Depth-First Search.
  <a class="anchor" href="#depth-first-search">#</a>
</h4>
<p>DFS begins at a given node, then proceeds to nodes reachable from there using
the edges of the graph. Once it visits all neighbour nodes, it returns to
previous nodes, checking if the neighbours have been seen, and so on until it
finds an unvisited, until all nodes are visited.</p>
<p>Implementation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#888;font-style:italic">//Assuming adjacency list 
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; adj[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">//Array to keep track of visited nodes
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;text-decoration:underline">bool</span> visited[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">//Check if node is visited, if so return, else set visited[s] to true
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">dfs</span>(<span style="font-weight:bold;text-decoration:underline">int</span> s) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span>(visited[s]) = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>  visited[s] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// process node s
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// iterates over the neighbors of node s
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">auto</span> u: adj[s]) {
</span></span><span style="display:flex;"><span>    dfs(u);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 class="heading" id="breadth-first-search">
  Breadth-First Search
  <a class="anchor" href="#breadth-first-search">#</a>
</h4>
<p>This begins at a given node, then visits all the other nodes at an increasing
distance from the starting node. Thus, we can calculate the distance from the
starting node to other nodes using  breadth first search. This is harder to
implement, though.</p>
<p>We start from our first node, then add the neighbours to the queue. As opposed
to the stack in DFS, which is FIFO, the queue in BFS is LIFO. We popleft() to
take the next element in a queue, whereas we pop() to take off the rearmost
element in a stack, if we are adding elements by append().</p>
<p>An example implementation in cpp.
The queue q contains all the nodes to be visited in order of their distance.
Visited contains then already seen nodes, and the array ddistance contains teh
distances from the starting node to all nodes of the graph.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>queue&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; q;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> visited[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> distance[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">//starting at node x
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>
</span></span><span style="display:flex;"><span>visited[x] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>distance[x] = 0;
</span></span><span style="display:flex;"><span>q.push(x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">while</span>(!q.empty()) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> s = q.front(); q.pop();
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">auto</span> u : adj[s]) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (visited[u]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>    visited[u] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>    distance[u] = distance[s]+1
</span></span><span style="display:flex;"><span>    q.push(u);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Time complexity is O(m+n) where we have n nodes and m edges.</p>
<h3 class="heading" id="shortest-paths">
  Shortest paths
  <a class="anchor" href="#shortest-paths">#</a>
</h3>
<h4 class="heading" id="bellman-ford">
  Bellman-Ford
  <a class="anchor" href="#bellman-ford">#</a>
</h4>
<p>This algorithm finds the shortest path from a starting node to all nodes of the
graph. It can cope with any kind of graph except those containing a cycle of
negative length.</p>
<p>On each round of the algorithm it goes through all the edges of the graph to try
to find the smallest distances.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i; i &lt;= n; i++) distance[i] = INF;
</span></span><span style="display:flex;"><span>distance[x] = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n-1; i++) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">auto</span> e : edges) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> a, b, w;
</span></span><span style="display:flex;"><span>    tie(a, b, w) = e;
</span></span><span style="display:flex;"><span>    distance[b] = min(distance[b], distance[a]+w);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Time complexity is O(nm) because it consists of n-1 rounds and iterates through
all m edges.</p>
<h4 class="heading" id="dijkstras-algorithm">
  Dijkstra&rsquo;s Algorithm
  <a class="anchor" href="#dijkstras-algorithm">#</a>
</h4>
<p>Like with BF, we initially set the distance to the origin node to 0 and the
distances to every other node to infinity. At each step the algorithm checks the
closes possible node that has not yet been seen. (Algorithms that do this &ldquo;local
optimisation&rdquo; are called a &ldquo;greedy&rdquo;).</p>
<p>Once a node is picked, the algorithm then does the same, picking the closes
unvisited node. As with BF, this algorithm doesn&rsquo;t work with graphs with
negative edges.</p>
<p>The most efficient way to implement this is to use a priority queue - the
neighbour nodes are ordered by distance, meaning it will be able to retrieve the
next node in logarithmic time.</p>
<p>In the below implementation, the priority queue q contains pairs of the form
(-d, x), meaning that the distance to x is d. We also have an array distance to
keep track of distances to each node, and processed to keep track of whether
we&rsquo;ve seen that node yet, like in DFS and BFS.</p>
<p>The distances are negative because the Cpp priority queue DS finds maximum
elements, whereas we want to find minimum elements.</p>
<p>Implementation below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">for</span>(<span style="font-weight:bold;text-decoration:underline">int</span> i = 1l i &lt;= n; i++) distance[i] = INF;
</span></span><span style="display:flex;"><span>distance[x] = 0;
</span></span><span style="display:flex;"><span>q.push({0, x});
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">while</span>(!q.empty()) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> a = q.top().second; q.pop();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (procesed[a]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>  processed[a] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">auto</span> u : adj[a]) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Time complexity is O(n + mlogm)</p>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/notes/data-structures-and-algorithms/greedy-algorithms/">
                        Greedy Algorithms
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/notes/data-structures-and-algorithms/complete-search/">
                        Complete Search
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
