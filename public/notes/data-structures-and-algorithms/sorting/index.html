<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    Sorting | The Cave of Treasures
    
</title>

<link rel="canonical" href="http://localhost:1313/notes/data-structures-and-algorithms/sorting/"/>

<meta property="og:url" content="http://localhost:1313/notes/data-structures-and-algorithms/sorting/">
  <meta property="og:site_name" content="The Cave of Treasures">
  <meta property="og:title" content="Sorting">
  <meta property="og:description" content="Putting everything in order.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="notes">
    <meta property="article:published_time" content="2025-08-09T13:19:56+01:00">
    <meta property="article:modified_time" content="2025-08-09T13:19:56+01:00">












<link rel="stylesheet" href="/assets/combined.min.62d3d68b86ab80ae1348b39991816cb99fd247ba4c3436eaa0d0d7e260019425.css" media="all">











    




</head>







<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">The Cave of Treasures</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/notes" >
                /notes
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/translations" >
                /translations
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/notes/">Notes</a><span class="breadcrumbs-separator">/</span><a href="/notes/data-structures-and-algorithms/">Data Structures and Algorithms</a><span class="breadcrumbs-separator">/</span>
        <a href="/notes/data-structures-and-algorithms/sorting/">Sorting</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">Sorting</h1>
        <p class="single-summary">Putting everything in order.</p>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-08-09T13:19:56&#43;01:00">August 9, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
      <aside class="toc">
        <p><strong>Table of contents</strong></p>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#sorting">Sorting</a></li>
      </ul>
    </li>
  </ul>
</nav>
      </aside>
    
    <div class="single-content">
      <h3 class="heading" id="sorting">
  Sorting
  <a class="anchor" href="#sorting">#</a>
</h3>
<h4 class="heading" id="bubble-sort">
  Bubble Sort
  <a class="anchor" href="#bubble-sort">#</a>
</h4>
<p>This is a very simple and famous sorting algorithm where the values &ldquo;bubble up&rdquo;
to the top. It requires 2 nested loops. It consists of n rounds, where on each
round, the algorithm switches the locations of every 2 elements where the latter
is larger than the earlier, essentially swapping every 2 consecutive elements to
be in the correct order. After this the total array will be in order.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; n; i++){
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> <span style="font-weight:bold;text-decoration:underline">int</span> (j = 0; j &lt; n-1; j++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (array[j] &gt; array[j+1]) {
</span></span><span style="display:flex;"><span>            swap(array[j], array[j+1];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After the first round, the largest element will be in position. After k rounds,
the k largest elements will be in position. Hence, after n rounds, all will be
in order.</p>
<p>Because it requires 2 loops, operating over n rounds, with n swaps maximum
needed for a completely reverse ordered array, time complexity is $O(n^2)$</p>
<h4 class="heading" id="merge-sort">
  Merge Sort
  <a class="anchor" href="#merge-sort">#</a>
</h4>
<p>How can we make our sorting algorithm more efficient? We can do this by not
limiting ourselves to consecutive elements being swapped. Merge sort does this,
by splitting the array into sub arrays, sorting those, then merging the result.</p>
<p>In more detail, mergesort sorts a subarray [a..b] like so:</p>
<ol>
<li>If a = b, do nothing. It&rsquo;s already sorted!</li>
<li>Find the middle element $k = lower((a+b)/2)$</li>
<li>Recursively sort that subarray $[a&hellip;k]$</li>
<li>Recursively sort the other subarray $[k+1&hellip;b]$</li>
<li>Merge the sorted subarrays array $[a&hellip;k]$ and array $[k+1&hellip;b]$ into a
sorted subarray $[a&hellip;b]$</li>
</ol>
<p>Merge sort is efficient because it halves the size of the subarray at each step,
consisting of $O(n\log{n})$</p>
<p>An implementation is below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#include</span> <span style="color:#888;font-weight:bold">&lt;vector&gt;</span><span style="color:#888;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">using</span> <span style="font-weight:bold;text-decoration:underline">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; Merge(vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt;&amp; left, vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt;&amp; right) {
</span></span><span style="display:flex;"><span>    vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; output;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (!left.empty() &amp;&amp; !right.empty()) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> min_num = (left[0] &lt;= right[0]) ? left[0] : right[0];
</span></span><span style="display:flex;"><span>        output.push_back(min_num);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (left[0] &lt;= right[0]) {
</span></span><span style="display:flex;"><span>            left.erase(left.begin());
</span></span><span style="display:flex;"><span>        } <span style="font-weight:bold;text-decoration:underline">else</span> {
</span></span><span style="display:flex;"><span>            right.erase(right.begin());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    output.insert(output.end(), left.begin(), left.end());
</span></span><span style="display:flex;"><span>    output.insert(output.end(), right.begin(), right.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> output;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; MergeSort(vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt;&amp; arr) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> n = arr.size();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (n &lt;= 1) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> arr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> mid = n / 2;
</span></span><span style="display:flex;"><span>    vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; left(arr.begin(), arr.begin() + mid);
</span></span><span style="display:flex;"><span>    vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; right(arr.begin() + mid, arr.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    left = MergeSort(left);
</span></span><span style="display:flex;"><span>    right = MergeSort(right);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> <span style="color:#666;font-weight:bold;font-style:italic">Merge</span>(left, right);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Time complexity is $O(n\log{n})$</p>
<h4 class="heading" id="binary-search">
  Binary Search
  <a class="anchor" href="#binary-search">#</a>
</h4>
<p>This is a very efficient way of searching an array that relies on the array
being sorted. A main application of sorting data is to making searching more
efficient - think of a phone book or any other kind of directory.</p>
<p>Implementation below:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> k = 0;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> b = n/2; b &gt;= 1; b /= 2) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (k+b &lt; v &amp;&amp; array[k+b] &lt;= x) k += b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">if</span> (array[k] == x){
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// x is found at k
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>}
</span></span></code></pre></div><p>What this does is use progressively smaller jumps, and checks at each jump if
the value at the jumped-to position is bigger or smaller than x. If x is bigger,
then we note the jumped position as k and jump again, adding our smaller jump to
k. If not, we jump from the start of the array, as we didn&rsquo;t do k += b. The idea
is that at each step the jump length is halved, and the variable k keeps track
of where we jumped to if x is larger, getting us to jump to the right of our
last jump, and if not, makes us jump into the sub array on the left.</p>
<p>Time complexity is $O(\log{n})$</p>

    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/notes/data-structures-and-algorithms/complete-search/">
                        Complete Search
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
